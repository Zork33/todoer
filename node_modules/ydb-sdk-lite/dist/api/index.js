"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grpc = exports.getOperationPayload = void 0;
/**
 * GRPC adapter.
 */
const debug_1 = __importDefault(require("debug"));
const grpc = __importStar(require("@grpc/grpc-js"));
const bundle_1 = require("../../proto/bundle");
const payload_1 = require("./payload");
Object.defineProperty(exports, "getOperationPayload", { enumerable: true, get: function () { return payload_1.getOperationPayload; } });
const debug = (0, debug_1.default)('ydb-sdk-lite:api');
const DEFAULT_ENDPOINT = 'grpcs://ydb.serverless.yandexcloud.net:2135';
const TableService = bundle_1.Ydb.Table.V1.TableService;
const ScriptingService = bundle_1.Ydb.Scripting.V1.ScriptingService;
const DiscoveryService = bundle_1.Ydb.Discovery.V1.DiscoveryService;
const identity = (x) => x;
class Grpc {
    constructor({ endpoint, dbName, iamToken }) {
        this.endpoint = removeGrpcProtocol(endpoint || DEFAULT_ENDPOINT);
        this.dbName = dbName;
        this.iamToken = iamToken;
        this.client = createGrpcClient(this.endpoint);
        this.metadata = this.createMetadata();
        this.tableService = this.createService('Ydb.Table.V1.TableService', TableService);
        this.scriptingService = this.createService('Ydb.Scripting.V1.ScriptingService', ScriptingService);
        this.discoveryService = this.createService('Ydb.Discovery.V1.DiscoveryService', DiscoveryService);
    }
    createMetadata() {
        const metadata = new grpc.Metadata();
        metadata.add('x-ydb-database', this.dbName);
        metadata.add('x-ydb-auth-ticket', this.iamToken);
        metadata.add('x-ydb-sdk-build-info', 'ydb-nodejs-sdk/1.9.0');
        return metadata;
    }
    createService(serviceName, ctor) {
        const rpcImpl = (method, requestData, callback) => {
            const path = `/${serviceName}/${method.name}`;
            this.client.makeUnaryRequest(path, identity, identity, requestData, this.metadata, {}, callback);
        };
        const service = ctor.create(rpcImpl);
        debug(`Service created: ${serviceName}`);
        return service;
    }
    /**
     * Сейчас дискавери возвращает 3 ендпойнта со списком доступных сервисов:
     * - ru-central1-a.ydb.serverless.yandexcloud.net
     * - ru-central1-b.ydb.serverless.yandexcloud.net
     * - ru-central1-c.ydb.serverless.yandexcloud.net
     * В основном sdk они ротируются, и если какой-то отвечает ошибкой, то он пессимизируется.
     * Тут дискавери пока отключил, т.к. это лишние 100мс, а профит для функций не очень ясен.
     * Кейс когда это полезно - если упадет именно ydb.serverless.yandexcloud.net,
     * который сейчас сам роутит на один из этих серверов.
     *
     * Еще вариант - запускать дисквери параллельно с основным запросом.
     * Тогда в случае ошибки запроса мы уже будем иметь список серверов.
     *
     * Вобщем, наблюдаем. Это метод пока нигде не используется.
     */
    async discoverEndpoints() {
        debug(`Discovery started`);
        const time = Date.now();
        const response = await this.discoveryService.listEndpoints({ database: this.dbName });
        const payload = (0, payload_1.getOperationPayload)(response);
        const data = bundle_1.Ydb.Discovery.ListEndpointsResult.decode(payload);
        debug(`Discovery done (${Date.now() - time}ms): ${JSON.stringify({ data })}`);
        return data;
    }
}
exports.Grpc = Grpc;
function createGrpcClient(endpoint) {
    // todo: support unsecure connection
    return new grpc.Client(endpoint, grpc.credentials.createSsl());
}
function removeGrpcProtocol(url) {
    return url.replace(/^grpcs?:\/\//, '');
}
//# sourceMappingURL=index.js.map